# 開発スタイル（壁打ち前提） — NemuKei方式

## 目的
この文書は、私（ユーザー）の開発スタイル・運用ルールを言語化し、ChatGPT / Codex と壁打ちする際の前提（共通理解）として使うためのもの。  
新しいプロジェクトが発生したときも、原則としてこの文書を起点に意思決定・タスク分解・作業運用を行う。

## 前提
- 開発対象は「業務で使う運用ツール」。完成度よりも **再現性・運用性・改善可能性** を優先する。
- ユーザーは職業プログラマーではないが、Python / Git / Excel / VSCode を日常的に使う。
- AIは強力だが、推測で走ると高確率で事故るため、品質ゲートを設けて運用する。

---

## 1. 基本原則（破ると事故る）

### 1-1. Single Source of Truth（唯一の正）
- **仕様（外部仕様・ロジック定義の唯一の正）**：`docs/spec_*.md`
- **AI運用ルール（プロンプト規約・禁止事項の唯一の正）**：`AGENTS.md`
- **計画（将来予定・優先度の唯一の正）**：`docs/roadmap.md`, `docs/tasks_backlog.md`
- **ユーザーマニュアル**：`README` / `*_README.txt`

※「仕様」と「計画」を混同しない。計画は“やる予定”であり、現状の挙動の根拠にはしない。

### 1-2. 推測で進めない（品質ゲート）
- 判断に必要なファイルが足りていない場合は、**推測で進めずに要求**する。
- まだ不足している情報がある場合は、**推測で進めずに壁打ちに切り替える（Codex用プロンプトは出さない）**。
- 仮定で進める場合は、**仮定を箇条書きで明示**し、承認された場合のみ進める。

### 1-3. 再現性とロールバック最優先
- 変更はロールバック可能にする（ブランチ運用、タグ、リリース、コミット分割）。
- 「動いた」だけで終わらせず、**再現条件・入力・出力・検証手順**を残す。

### 1-4. 運用の現実を優先
- “柔軟仕様”より、現場で回る **現実的な落とし所** を優先する。
- パフォーマンスが怪しい案は、計算量・処理時間の見込みに触れて判断する。

---

## 2. 役割分担（ChatGPT と Codex の使い分け）

### ChatGPT（参謀役）
- 要件整理・仕様検討・設計方針の提案
- ロジックレビュー（弱点・盲点・バグ筋の指摘）
- Codexに渡すプロンプト作成（スコープ固定／完了条件明記）
- ドキュメント草案（spec / README / handover）

### Codex（実装役）
- 実コードの編集・ファイル操作
- テスト実行（可能な範囲）
- ただし **`docs/` の仕様書は原則 read-only**（人間レビュー前提でのみ提案）

---

## 3. 進め方（標準ワークフロー）
1) **目的の確認**（何を解決するか／使う人／使う頻度／失敗時の影響）  
2) **仕様確認**（`spec_*` と `AGENTS` を読む。曖昧なら壁打ち）  
3) **タスク分解**（P0/P1/P2、完了条件つき）  
4) **実装方針の決定**（最小修正 → 追加改善の順）  
5) **Codex用プロンプト作成**（スコープ固定、参照仕様明記）  
6) **実装・テスト**（Ruff / 実行確認 / 主要パスの動作）  
7) **レビュー**（矛盾、例外、欠損、境界条件）  
8) **マージ／タグ／リリース**（必要なら CHANGELOG）  
9) **引き継ぎ更新**（未解決・次アクション・注意点）

---

## 4. Codex用プロンプトの標準（スコープ逸脱防止）

### 必須要素
- **参照すべき仕様ファイル**（例：`spec_data_layer.md` / `spec_models.md` / `spec_evaluation.md`）
- **タスクIDとスコープ**（例：`P0-03` のみ。周辺は触らない）
- **完了条件**（例：既存CSV互換、既存テストを落とさない、など）
- 出力方針：**修正後のファイル全体**（差分ではなく置換前提）

### 形式
- 説明パート（1〜3行）
- Pythonコメントだけの大きなコードブロック（`#`のみ）

---

## 5. コード品質の基準（最低ライン）
- Python 3 / GUIはTkinter（EXE化想定）
- `ruff` を前提に、未使用importや雑な書き捨てを残さない
- 変数名・関数名は英語で役割が分かるもの
- マジックナンバーは定数化（または設定化）
- 重要処理には docstring（「入力」「出力」「例外」「注意点」）
- バグが疑われる場合：最小の入力例（テストケース）で再現イメージを残す

---

## 6. ファイル共有・版管理の運用（参照齟齬を潰す）

### 6-1. 共有は「ZIP生成スクリプト」を唯一の手段にする
- スレッド移行・修正レビュー・再現確認など、共有が必要な場面では **必ず ZIP を作って渡す**。
- ZIP は **手作業で選別しない**（漏れ・混入・同名事故の原因になる）。
- ZIP には以下を必ず同梱する：
  - `VERSION.txt`（生成時刻、ブランチ、コミット等）
  - `MANIFEST.txt`（同梱ファイル一覧）
- ZIP は `packages/` 配下に出力し、ZIPファイル名で識別できるようにする。

### 6-2. ZIP生成スクリプト（make_release_zip.py）
- リポジトリルートで以下を実行して ZIP を作成する（標準）：

  - コードのみ（git管理ファイル中心）
    - `python make_release_zip.py`
  - 出力サンプルやログも同梱（必要なときだけ）
    - `python make_release_zip.py --with-output-samples --max-logs 1`

- 生成される ZIP には `VERSION.txt` と `MANIFEST.txt` が自動で含まれる。
- `--tag` を省略した場合、時刻＋samples有無＋branch＋commitから自動タグが付く。

### 6-3. サンプルデータ運用（機密事故を潰す）
- `--with-output-samples` を使う場合、同梱されるサンプルは **必ず個人情報・企業機密を排したダミー** のみとする。
- 実データ・予約情報・顧客情報・社内固有の識別子が含まれる可能性があるものは **同梱しない**。
- “便利だから”で例外運用しない（事故の機会費用が大きすぎる）。

### 6-4. 共有前の安全確認（漏洩事故を潰す）
- スクリプトの警告（危険そうな名称スキャン）は必ず確認し、必要なら除外や削除をしてから共有する。
- `.env` / token / password / credential 系のファイルは **原則リポジトリ外**、共有対象外。

### 6-5. スレッド運用との接続
- 新スレッドでは「引き継ぎ本文」＋「アンカーZIP（packages/ に置くZIP）」をセットで渡す。
- 参照齟齬が疑われる場合は、ZIPの `VERSION.txt` / `MANIFEST.txt` を根拠に “どれが最新か” を確定してから進める。

---

## 7. スレッド運用（コンテキスト崩壊を防ぐ）

### 7-1. スレッド移行の推奨条件
- トークン肥大化で、**回答が不安定になり始める前兆**が出た
- 同名ファイルが増え、参照齟齬が疑われる
- 前提が多層化して「何が最新か」を明示しないと危険になった
- 各回答に A-番号を付ける
- A-25 で締めモード
- A-番号逸脱は即停止

### 7-2. 新スレッド冒頭の宣言（テンプレ運用）
- 新スレの冒頭で「これは引き継ぎ本文であり、添削ではなく受領して進める」ことを明記する。
- さらに「ファイル確認必須」「推測禁止」「不足なら要求」を冒頭ルールとして固定する。
- 用語定義：アンカーZIP（=anchor_zip）＝このスレッドで唯一の正として固定参照するZIP（スレッド冒頭で添付されるZIP）
- 用語定義：source_zip＝引継書作成の材料になったZIP（引継依頼時点のZIP）。
- 用語定義：candidate_zip＝スレッド途中で確認・検証のために共有する修正版ZIP（検証対象）。
- 運用要件：source_zip と anchor_zip が異なる場合は、引継書本文に source_zip（ZIP名/branch/commit）を明記する（監査用）。次スレの参照の唯一の正は anchor_zip。
- 運用要件：スレッド途中に candidate_zip を渡して検証する場合、アンカーZIPは固定のまま扱う。candidate_zip を唯一の正として以後進める場合は新スレッドへ移行する。
- スレッドを跨ぐときは、新しく作成したZIPを次スレで添付し、そのZIPを次スレのアンカーZIPとして固定する。
- 共有ファイルは **make_release_zip.py で作成したアンカーZIPを唯一の正** とし、手作業での個別ファイル添付は原則しない。
- 次スレ冒頭で Docs Gate が Yes の場合、docs更新は `docs/templates/prompt_docs_update.md` を唯一の手順として行う。

#### docs更新の実務（出力形式）
- 既定は `prompt_docs_update.md` の Mode-A（全文出力）。
- ただし「差分だけを正確に当てたい」「レビューを楽にしたい」場合は Mode-B（unified diff）を使ってよい。
- Mode-B は **機械適用（git apply / apply_patch）前提**で、変更ブレを減らすための運用。
- 注意：`AGENTS.md` の通り docs は原則「人間＋ChatGPT」が編集する。
  - Codex を使う場合は「diffをそのまま適用する（追加提案なし）」の **明示指示**がある時のみ “適用係” として利用する。
  - 適用後は必ず人間が差分レビューしてからマージする。

#### 引き継ぎ（ファイル化が標準）
- 引き継ぎ本文は `docs/handovers/YYYY-MM-DD_HHMM_<type>_<scope>__handover.md` として保存し、ZIPに同梱する。
- 次スレ冒頭は「アンカーZIP添付＋ handoverファイルパス指定」だけを書き、全文貼りは原則しない（トークン節約と参照齟齬防止）。

### 7-3. スレッド終了時のログ作成（必須・5分ゲート）

スレッドを跨ぐ開発は、**「決定事項の喪失」「docs反映漏れ」「ZIP/commitの参照齟齬」**が最大の事故原因になる。  
よって、各スレッドの最後に必ず **Thread Log → Decision Log** を作成する（append-only運用）。

#### 生成する成果物
- Thread Log（スレッド単位・少し詳細・append-only）
  - 保存先：`docs/thread_logs/YYYY-MM-DD_HHMM_<type>_<scope>__thread_log.md`
- Decision Log（横断・決定だけ）
  - 保存先：`docs/decision_log.md`

#### 運用ルール（重要）
- Thread Log / Decision Log は **仕様ではない**。仕様の唯一の正は `docs/spec_*.md`。
- Decision Log には必ず **Spec link（反映先spec）** と **Status（spec反映済/未反映）** を付ける。
- 「整える」のは仕様書。ログは **5分で終える**（長文化禁止）。

#### テンプレの参照先（唯一の正）
- Thread Log 生成：`docs/templates/prompt_thread_log_generate.md`
- Decision Log 更新：`docs/templates/prompt_decision_log_update.md`
- 引き継ぎ依頼：`docs/templates/handover_request.md`
- 引き継ぎ本文：`docs/templates/handover_body.md`
- docs 更新：`docs/templates/prompt_docs_update.md`

### 7-4. スレッド移行時の確認ルーチン（引き継ぎ受領ゲート）

スレッド跨ぎの最大リスクは、引継書・ログ・コード・specの参照齟齬である。  
新スレッド開始時は、引継書の読解だけで進めず、必ず「アンカーZIPでの検算」を行う。

#### 必須確認（最小セット）
- アンカーZIPを展開し、以下を確認
  1) `docs/thread_logs/` の **直近Thread Log（原則1本）**
  2) `docs/decision_log.md` の **末尾（直近10〜20件）**
- 引継書の主張と、上記ログおよび現行コード/仕様（spec_*）が矛盾しないか検算する

#### 矛盾・不明点が出た場合の対応（固定）
- 推測で埋めずに「前スレッドに確認するための質問プロンプト」を作成してから作業に入る
- 質問は最大5つ（Yes/No または短文回答が可能な形を優先）
- 目的は前提の確定。論点追加や設計議論は避ける（必要なら別スレッドでやる）

#### ログ未整備時
- Thread Log / Decision Log が未更新なら、まず不足として指摘し、必要なら先に作成する

---